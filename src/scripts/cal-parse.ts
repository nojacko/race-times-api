import * as fs from "fs";
import * as path from "path";
import { calendars } from "../data/calendars";
import { sessionByFormula } from "../utils/sessions";
import type { RaceSession } from "../types/RaceSession";

function unfoldLines(raw: string): string[] {
  const lines = raw.replace(/\r\n/g, "\n").split("\n");
  const out: string[] = [];
  for (const line of lines) {
    if (line.startsWith(" ") || line.startsWith("\t")) {
      // continuation: append to previous
      if (out.length === 0) out.push(line.trim());
      else out[out.length - 1] += line.slice(1);
    } else {
      out.push(line);
    }
  }
  return out;
}

function parseIcs(content: string): RaceSession[] {
  const lines = unfoldLines(content);
  const events: string[][] = [];
  let inEvent = false;
  let current: string[] = [];
  for (const line of lines) {
    if (line === "BEGIN:VEVENT") {
      inEvent = true;
      current = [];
      continue;
    }
    if (line === "END:VEVENT") {
      inEvent = false;
      events.push(current.slice());
      current = [];
      continue;
    }
    if (inEvent) current.push(line);
  }

  const sessions: RaceSession[] = [];

  for (const ev of events) {
    const props: Record<string, string> = {};
    for (const line of ev) {
      const idx = line.indexOf(":");
      if (idx === -1) continue;
      const keyWithParams = line.slice(0, idx);
      const value = line.slice(idx + 1);
      const key = keyWithParams.split(";")[0];
      props[key] = value;
    }

    function toIso(s?: string, ctx?: string): string {
      if (!s) return "";
      // Expect formats like YYYYMMDDTHHMMSSZ or YYYYMMDDTHHMMZ
      const mFull = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})Z?$/);
      const mShort = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})Z?$/);
      if (mFull) {
        const [, y, mon, d, hh, mm, ss] = mFull;
        return new Date(Date.UTC(+y, +mon - 1, +d, +hh, +mm, +ss)).toISOString();
      }
      if (mShort) {
        const [, y, mon, d, hh, mm] = mShort;
        return new Date(Date.UTC(+y, +mon - 1, +d, +hh, +mm, 0)).toISOString();
      }
      // Do not fallback to loose parsing â€” surface an error so the caller can fix input.
      throw new Error(`Unable to parse date "${s}"${ctx ? ` for ${ctx}` : ""}`);
    }

    const session: RaceSession = {
      summary: props["SUMMARY"] || "",
      // keep original ical values
      dtstamp: props["DTSTAMP"] || "",
      dtstart: props["DTSTART"] || "",
      dtend: props["DTEND"] || "",
      // ISO start/end for convenience
      startDateTime: props["DTSTART"] ? toIso(props["DTSTART"], props["SUMMARY"] || props["UID"]) : undefined,
      endDatetime: props["DTEND"] ? toIso(props["DTEND"], props["SUMMARY"] || props["UID"]) : undefined,
    };

    if (props["SEQUENCE"]) session.sequence = props["SEQUENCE"];
    if (props["GEO"]) {
      session.geo = props["GEO"];
      const [latS, lonS] = props["GEO"].split(";");
      const lat = parseFloat(latS);
      const lon = parseFloat(lonS);
      if (!Number.isNaN(lat) && !Number.isNaN(lon)) session.coords = { lat, lon };
    }
    if (props["LOCATION"]) session.location = props["LOCATION"];
    if (props["STATUS"]) session.status = props["STATUS"];
    if (props["CATEGORIES"]) session.categories = props["CATEGORIES"].split(",").map((s) => s.trim());

    sessions.push(session);
  }

  return sessions;
}

function sessionsToTsContent(varName: string, sessions: RaceSession[]): string {
  const header = `// Auto-generated by process-calendars.ts\n// Do not edit by hand.\n\n`;
  const importType = `import type { RaceSession } from "../types/RaceSession";\n\n`;

  const body = `export const ${varName}: RaceSession[] = ${JSON.stringify(sessions, null, 2)};\n`;

  return header + importType + body;
}

async function run(): Promise<void> {
  try {
    for (const cal of calendars) {
      if (!fs.existsSync(cal.file)) {
        console.warn(`Skipping ${cal.name}: calendar file not found at ${cal.file}`);
        continue;
      }

      const raw = fs.readFileSync(cal.file, "utf8");
      const sessions = parseIcs(raw);
      // enrich sessions with formulaSlug and sessionTypeSlug
      const typesForCal = sessionByFormula(cal.formula) || [];
      if (!typesForCal || typesForCal.length === 0) {
        console.error(`No session types for formula "${cal.formula}" (calendar: ${cal.name}), skipping.`);
        continue;
      }
      for (const s of sessions) {
        s.formulaSlug = cal.formula;
        let matched: string | undefined = undefined;
        if (s.categories && s.categories.length > 0) {
          const cats = s.categories.map((c) => c.toLowerCase());
          for (const t of typesForCal) {
            if (!t || !t.calCategory) continue;
            if (cats.includes(t.calCategory.toLowerCase())) {
              matched = t.slug;
              break;
            }
          }
        }
        if (matched) s.sessionTypeSlug = matched;
      }
      const varName = `${cal.name.toLowerCase()}Sessions`;
      const content = sessionsToTsContent(varName, sessions);

      const outPath = cal.tsOutput;
      const outDir = path.dirname(outPath);
      if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

      fs.writeFileSync(outPath, content, "utf8");
      console.log(`Wrote ${outPath} (${sessions.length} sessions)`);
      console.log("");
    }
  } catch (err) {
    console.error("process-calendars failed:", err);
    process.exit(1);
  }
}

run();
