import * as fs from "fs";
import * as path from "path";
import { calendars } from "../data/calendars";
import { sessionsByFormula, calendarEventsByFormula, racesByFormula } from "../utils/data";
import { formulas } from "../data/formulas";
import type { CalendarEvent } from "../types/CalendarEvent";
import type { RaceSession } from "../types/RaceSession";

function toIso(s?: string, ctx?: string): string {
  if (!s) return "";
  const mFull = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})Z?$/);
  const mShort = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})Z?$/);
  if (mFull) {
    const [, y, mon, d, hh, mm, ss] = mFull;
    return new Date(Date.UTC(+y, +mon - 1, +d, +hh, +mm, +ss)).toISOString();
  }
  if (mShort) {
    const [, y, mon, d, hh, mm] = mShort;
    return new Date(Date.UTC(+y, +mon - 1, +d, +hh, +mm, 0)).toISOString();
  }
  throw new Error(`Unable to parse date "${s}"${ctx ? ` for ${ctx}` : ""}`);
}

function sessionsToTsContent(varName: string, sessions: RaceSession[]): string {
  const header = `// Auto-generated by process-calendars.ts\n// Do not edit by hand.\n\n`;
  const importType = `import type { RaceSession } from "../types/RaceSession";\n\n`;

  const body = `export const ${varName}: RaceSession[] = ${JSON.stringify(sessions, null, 2)};\n`;

  return header + importType + body;
}

async function run(): Promise<void> {
  try {
    for (const formula of formulas) {
      const cal = calendars.find((c) => c.formula === formula.slug);
      if (!cal) {
        console.warn(`No calendar configured for formula ${formula.slug}, skipping.`);
        continue;
      }

      const events: CalendarEvent[] = calendarEventsByFormula(formula.slug) || [];
      if (!events || events.length === 0) {
        console.log(`No events for formula ${formula.slug}`);
      }

      const races = racesByFormula(formula.slug) || [];
      if (!races || races.length === 0) {
        console.error(`No races for formula "${formula.slug}". Skipping.`);
        continue;
      }

      const typesForCal = sessionsByFormula(formula.slug) || [];
      if (!typesForCal || typesForCal.length === 0) {
        console.error(`No session types for formula "${formula.slug}". Skipping.`);
        continue;
      }

      const sessions: RaceSession[] = [];
      for (const props of events) {
        const formulaSlug: string = formula.slug;
        const startDateTime: string = props["DTSTART"] ? toIso(props["DTSTART"], props["SUMMARY"] || props["UID"]) : "";
        const endDatetime: string = props["DTEND"] ? toIso(props["DTEND"], props["SUMMARY"] || props["UID"]) : "";
        let coords: { lat: number; lon: number } = { lat: 0, lon: 0 };

        if (props["GEO"]) {
          const [latS, lonS] = (props["GEO"] || "").split(";");
          const lat = parseFloat(latS as string);
          const lon = parseFloat(lonS as string);
          if (!Number.isNaN(lat) && !Number.isNaN(lon)) coords = { lat, lon };
        }

        // enrich
        let sessionTypeSlug: string = "";
        let raceSlug: string = "";
        const cats = props["CATEGORIES"] ? props["CATEGORIES"].split(",").map((c) => c.trim().toLowerCase()) : [];
        if (cats.length > 0) {
          for (const t of typesForCal) {
            if (!t || !t.calCategory) continue;
            if (cats.includes(t.calCategory.toLowerCase())) {
              sessionTypeSlug = t.slug;
              break;
            }
          }
        }

        const summary = (props["SUMMARY"] || "").toLowerCase();
        if (summary && races && races.length > 0) {
          for (const r of races) {
            if (!r || !r.name) continue;
            if (summary.includes(r.name.toLowerCase())) {
              raceSlug = r.slug;
              break;
            }
          }
        }

        const session: RaceSession = {
          formulaSlug,
          sessionTypeSlug,
          raceSlug,
          startDateTime,
          endDatetime,
          coords,
        };

        sessions.push(session);
      }

      // validate: every attribute on each session must be a non-empty string
      const invalidSessions = sessions.filter((s) => {
        for (const k of Object.keys(s)) {
          const v = (s as any)[k];
          if (k === "coords") {
            if (isNaN(v.lat) || isNaN(v.lon) || !Number.isFinite(v.lat) || !Number.isFinite(v.lon)) return true;
          } else {
            if (typeof v !== "string" || v.length === 0) return true;
          }
        }
        return false;
      });
      if (invalidSessions.length > 0) {
        for (const bad of invalidSessions) {
          console.error("Invalid session (missing/empty string attribute):", bad);
        }
      }

      const outPath = cal.raceSessionsFile;
      const outDir = path.dirname(outPath);
      if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

      const outVar = `${cal.name.toLowerCase()}Sessions`;
      const content = sessionsToTsContent(outVar, sessions);
      fs.writeFileSync(outPath, content, "utf8");
      console.log(`Wrote ${outPath} (${sessions.length} sessions)`);
      console.log("");
    }
  } catch (err) {
    console.error("process-calendars failed:", err);
    process.exit(1);
  }
}

run();
