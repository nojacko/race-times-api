import * as fs from "fs";
import * as path from "path";
import { calendars } from "../data/calendars";
import { sessionsByFormula, calendarEventsByFormula } from "../utils/data";
import { formulas } from "../data/formulas";
import type { CalendarEvent } from "../types/CalendarEvent";
import type { RaceSession } from "../types/RaceSession";

function toIso(s?: string, ctx?: string): string {
  if (!s) return "";
  const mFull = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})Z?$/);
  const mShort = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})Z?$/);
  if (mFull) {
    const [, y, mon, d, hh, mm, ss] = mFull;
    return new Date(Date.UTC(+y, +mon - 1, +d, +hh, +mm, +ss)).toISOString();
  }
  if (mShort) {
    const [, y, mon, d, hh, mm] = mShort;
    return new Date(Date.UTC(+y, +mon - 1, +d, +hh, +mm, 0)).toISOString();
  }
  throw new Error(`Unable to parse date "${s}"${ctx ? ` for ${ctx}` : ""}`);
}

function sessionsToTsContent(varName: string, sessions: RaceSession[]): string {
  const header = `// Auto-generated by process-calendars.ts\n// Do not edit by hand.\n\n`;
  const importType = `import type { RaceSession } from "../types/RaceSession";\n\n`;

  const body = `export const ${varName}: RaceSession[] = ${JSON.stringify(sessions, null, 2)};\n`;

  return header + importType + body;
}

async function run(): Promise<void> {
  try {
    for (const formula of formulas) {
      const cal = calendars.find((c) => c.formula === formula.slug);
      if (!cal) {
        console.warn(`No calendar configured for formula ${formula.slug}, skipping.`);
        continue;
      }

      const events: CalendarEvent[] = calendarEventsByFormula(formula.slug) || [];
      if (!events || events.length === 0) {
        console.log(`No events for formula ${formula.slug}`);
      }

      const typesForCal = sessionsByFormula(formula.slug) || [];
      if (!typesForCal || typesForCal.length === 0) {
        console.error(`No session types for formula "${formula.slug}". Skipping.`);
        continue;
      }

      const sessions: RaceSession[] = [];
      for (const props of events) {
        const formulaSlug: string | undefined = formula.slug;
        const startDateTime: string | undefined = props["DTSTART"]
          ? toIso(props["DTSTART"], props["SUMMARY"] || props["UID"])
          : undefined;
        const endDatetime: string | undefined = props["DTEND"]
          ? toIso(props["DTEND"], props["SUMMARY"] || props["UID"])
          : undefined;
        let coords: { lat: number; lon: number } | undefined = undefined;

        if (props["GEO"]) {
          const [latS, lonS] = (props["GEO"] || "").split(";");
          const lat = parseFloat(latS as string);
          const lon = parseFloat(lonS as string);
          if (!Number.isNaN(lat) && !Number.isNaN(lon)) coords = { lat, lon };
        }

        // enrich
        let sessionTypeSlug: string | undefined = undefined;
        const cats = props["CATEGORIES"] ? props["CATEGORIES"].split(",").map((c) => c.trim().toLowerCase()) : [];
        if (cats.length > 0) {
          for (const t of typesForCal) {
            if (!t || !t.calCategory) continue;
            if (cats.includes(t.calCategory.toLowerCase())) {
              sessionTypeSlug = t.slug;
              break;
            }
          }
        }

        const session: RaceSession = {
          formulaSlug,
          sessionTypeSlug,
          startDateTime,
          endDatetime,
          coords,
        };

        sessions.push(session);
      }

      const outPath = cal.raceSessionsFile;
      const outDir = path.dirname(outPath);
      if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

      const outVar = `${cal.name.toLowerCase()}Sessions`;
      const content = sessionsToTsContent(outVar, sessions);
      fs.writeFileSync(outPath, content, "utf8");
      console.log(`Wrote ${outPath} (${sessions.length} sessions)`);
      console.log("");
    }
  } catch (err) {
    console.error("process-calendars failed:", err);
    process.exit(1);
  }
}

run();
